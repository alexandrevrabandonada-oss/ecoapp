param(
  [string]$Root = (Get-Location).Path
)

$ErrorActionPreference = "Stop"

function EnsureDir([string]$p) {
  if (-not $p) { return }
  if (-not (Test-Path $p)) { New-Item -ItemType Directory -Force -Path $p | Out-Null }
}

function WriteUtf8NoBom([string]$path, [string]$content) {
  $enc = New-Object System.Text.UTF8Encoding($false)
  EnsureDir (Split-Path -Parent $path)
  [System.IO.File]::WriteAllText($path, $content, $enc)
}

function BackupFile([string]$src, [string]$backupDir, [string]$root) {
  if (-not (Test-Path $src)) { return }
  EnsureDir $backupDir
  $rel = $src
  if ($root -and $src.StartsWith($root)) { $rel = $src.Substring($root.Length).TrimStart('\','/') }
  $safe = ($rel -replace '[\\/:*?"<>|]', '_')
  $dst = Join-Path $backupDir $safe
  Copy-Item -Force $src $dst
  Write-Host ("[BK] " + $dst)
}

function ReplaceInsideFirstArrSort([string]$raw) {
  $idx = $raw.IndexOf("arr.sort(")
  if ($idx -lt 0) { return $raw }

  # acha o fim do primeiro arr.sort(...) usando parênteses
  $i = $idx
  $open = 0
  $started = $false
  $inS = $false
  $inD = $false
  $inT = $false
  $esc = $false

  while ($i -lt $raw.Length) {
    $ch = $raw[$i]

    if ($esc) { $esc = $false; $i++; continue }
    if ($ch -eq '\') { 
      # escape em strings normais
      if ($inS -or $inD) { $esc = $true; $i++; continue }
    }

    if ($inS) { if ($ch -eq "'") { $inS = $false } ; $i++; continue }
    if ($inD) { if ($ch -eq '"') { $inD = $false } ; $i++; continue }
    if ($inT) { if ($ch -eq '`') { $inT = $false } ; $i++; continue }

    if ($ch -eq "'") { $inS = $true; $i++; continue }
    if ($ch -eq '"') { $inD = $true; $i++; continue }
    if ($ch -eq '`') { $inT = $true; $i++; continue }

    if ($ch -eq '(') { $open++; $started = $true; $i++; continue }
    if ($ch -eq ')') {
      if ($open -gt 0) { $open-- }
      $i++
      if ($started -and $open -eq 0) { break }
      continue
    }

    $i++
  }

  if ($i -ge $raw.Length) { return $raw }

  # inclui o ");" logo após, se existir
  $end = $i
  $tail = $raw.Substring($end)
  $m = [regex]::Match($tail, '^\s*;')
  if ($m.Success) { $end += $m.Length }

  $before = $raw.Substring(0, $idx)
  $mid = $raw.Substring($idx, $end - $idx)
  $after = $raw.Substring($end)

  # só troca p. / p?. dentro do sort
  $mid2 = $mid.Replace("p?.", "a?.").Replace("p.", "a.")
  return $before + $mid2 + $after
}

$stamp = Get-Date -Format "yyyyMMdd-HHmmss"
$me = "eco-step-119-fix-muralclient-sort-syntax-v0_1"
Write-Host ("== " + $me + " == " + $stamp)

$backupDir = Join-Path $Root ("tools\_patch_backup\" + $stamp + "-" + $me)
EnsureDir $backupDir

# --- PATCH 1: fix MuralClient.tsx
$target = Join-Path $Root "src\app\eco\mural\MuralClient.tsx"
if (-not (Test-Path $target)) { throw ("[STOP] alvo não encontrado: " + $target) }

BackupFile $target $backupDir $Root
$raw = Get-Content -Raw -ErrorAction Stop $target

# 1) conserta "arr    try {" -> "try {"
$raw2 = [regex]::Replace($raw, '(?m)^(\s*)arr\s+try\s*\{\s*$', '$1try {')

# 2) conserta linhas ".sort(" começando com ponto -> "arr.sort("
$raw2 = [regex]::Replace($raw2, '(?m)^(\s*)\.\s*sort\s*\(', '$1arr.sort(')

# 3) conserta p. / p?. dentro do primeiro arr.sort(...)
$raw2 = ReplaceInsideFirstArrSort $raw2

if ($raw2 -ne $raw) {
  WriteUtf8NoBom $target $raw2
  Write-Host ("[PATCH] fixed -> " + $target)
} else {
  Write-Host ("[PATCH] no changes needed -> " + $target)
}

# --- PATCH 2: garantir alias /api/eco/points2 -> /api/eco/points
$points2 = Join-Path $Root "src\app\api\eco\points2\route.ts"
EnsureDir (Split-Path -Parent $points2)

if (Test-Path $points2) { BackupFile $points2 $backupDir $Root }

$alias = @(
'// AUTO-GENERATED by tools/eco-step-119-fix-muralclient-sort-syntax-v0_1.ps1',
'// Alias: /api/eco/points2 -> /api/eco/points',
'',
'import { GET as GET_POINTS } from "../points/route";',
'',
'export const runtime = "nodejs";',
'export const dynamic = "force-dynamic";',
'',
'export async function GET(req: Request) {',
'  return GET_POINTS(req);',
'}',
''
) -join "`n"

WriteUtf8NoBom $points2 $alias
Write-Host ("[PATCH] alias -> " + $points2)

# --- REPORT
$report = @()
$report += "# $me"
$report += ""
$report += "- Time: $stamp"
$report += "- Backup: $backupDir"
$report += ""
$report += "## What/Why"
$report += "- Corrige sintaxe quebrada no MuralClient (arr try + .sort)."
$report += "- Corrige p. dentro do primeiro arr.sort para a. (evita 'p is not defined')."
$report += "- Cria alias /api/eco/points2 -> /api/eco/points (evita 404)."
$report += ""
$report += "## Patched"
$report += "- src/app/eco/mural/MuralClient.tsx"
$report += "- src/app/api/eco/points2/route.ts"
$report += ""
$report += "## Verify"
$report += "1) Ctrl+C -> npm run dev"
$report += "2) abrir /eco/mural (não pode mais dar erro de parse nem 'p is not defined')"
$report += "3) irm 'http://localhost:3000/api/eco/points2?limit=1' | ConvertTo-Json -Depth 30"
$report += ""

$reportPath = Join-Path $Root ("reports\" + $me + "-" + $stamp + ".md")
WriteUtf8NoBom $reportPath ($report -join "`n")
Write-Host ("[REPORT] " + $reportPath)

Write-Host ""
Write-Host "[VERIFY] rode:"
Write-Host "  Ctrl+C -> npm run dev"
Write-Host "  abrir /eco/mural"
Write-Host "  irm 'http://localhost:3000/api/eco/points2?limit=1' | ConvertTo-Json -Depth 30"