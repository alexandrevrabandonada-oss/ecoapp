// AUTO-GENERATED by tools/eco-step-117-fix-mural-links-and-actions-v0_1.ps1
// POST /api/eco/points/action  { pointId, action: "confirm"|"support"|"replicar", actor?, note? }
// Goal: never fail due to missing required fields (uses Prisma.dmmf to fill required scalar/enum fields).

import { NextResponse } from "next/server";
import { prisma } from "@/lib/prisma";
import { Prisma } from "@prisma/client";

export const runtime = "nodejs";
export const dynamic = "force-dynamic";

type AnyRec = Record<string, any>;

function toDelegate(name: string) {
  return name && name.length ? name.slice(0, 1).toLowerCase() + name.slice(1) : name;
}
function getDmmf(): any {
  return (Prisma as any).dmmf as any;
}
function getModels(): any[] {
  const d = getDmmf();
  return d && d.datamodel && Array.isArray(d.datamodel.models) ? d.datamodel.models : [];
}
function getEnums(): any[] {
  const d = getDmmf();
  return d && d.datamodel && Array.isArray(d.datamodel.enums) ? d.datamodel.enums : [];
}
function enumFirst(enumName: string): string | null {
  const e = getEnums().find((x: any) => x && x.name === enumName);
  const v = e && Array.isArray(e.values) && e.values.length ? e.values[0].name : null;
  return v || null;
}
function findModelByDelegate(delegateKey: string): any | null {
  return getModels().find((m: any) => m && toDelegate(m.name) === delegateKey) || null;
}
function findModelByName(modelName: string): any | null {
  return getModels().find((m: any) => m && m.name === modelName) || null;
}
function hasField(modelName: string, fieldName: string): boolean {
  const m = findModelByName(modelName);
  return !!(m && Array.isArray(m.fields) && m.fields.some((f: any) => f && f.name === fieldName));
}
function pickDelegate(pc: any, candidates: string[]): string | null {
  for (const c of candidates) {
    if (pc && pc[c]) return c;
  }
  return null;
}
function randId(prefix: string) {
  return prefix + "-" + Math.random().toString(36).slice(2, 8) + "-" + Date.now().toString(36);
}
function findFkField(modelName: string, targetModelName: string): string | null {
  const m = findModelByName(modelName);
  if (!m || !Array.isArray(m.fields)) return null;
  for (const f of m.fields) {
    if (f && f.kind === "object" && f.type === targetModelName) {
      const rff = (f as any).relationFromFields;
      if (Array.isArray(rff) && rff.length) return rff[0];
    }
  }
  const scalar = m.fields.find((f: any) => f && (f.kind === "scalar" || f.kind === "enum") && /pointId/i.test(f.name));
  return scalar ? scalar.name : null;
}
function buildRequiredData(modelName: string, base: AnyRec, ctx: AnyRec): AnyRec {
  const m = findModelByName(modelName);
  const out: AnyRec = {};
  const now = new Date();
  const fields = m && Array.isArray(m.fields) ? m.fields : [];
  for (const f of fields) {
    if (!f) continue;
    if (f.isList) continue;
    if (f.kind !== "scalar" && f.kind !== "enum") continue;
    if (!f.isRequired) continue;
    if (f.hasDefaultValue) continue;
    if (base && base[f.name] !== undefined) continue;
    if (f.name === "id") { out[f.name] = randId("id"); continue; }
    if (f.name === "createdAt" || f.name === "updatedAt") { out[f.name] = now; continue; }
    if (f.name === "actor") { out[f.name] = ctx.actor; continue; }
    if (f.name === "note") { out[f.name] = ctx.note; continue; }
    if (f.name === "fingerprint") { out[f.name] = "act-" + Date.now().toString(36) + "-" + Math.random().toString(36).slice(2, 8); continue; }
    if (f.kind === "enum") { out[f.name] = enumFirst(f.type) || "OPEN"; continue; }
    if (f.type === "String") { out[f.name] = ctx.actor; continue; }
    if (f.type === "Int" || f.type === "Float") { out[f.name] = 0; continue; }
    if (f.type === "Boolean") { out[f.name] = false; continue; }
    if (f.type === "DateTime") { out[f.name] = now; continue; }
    out[f.name] = ctx.actor;
  }
  for (const k of Object.keys(base || {})) out[k] = base[k];
  if (hasField(modelName, "actor") && out["actor"] === undefined) out["actor"] = ctx.actor;
  if (hasField(modelName, "note") && out["note"] === undefined) out["note"] = ctx.note;
  return out;
}
async function safeJson(req: Request): Promise<AnyRec> {
  try {
    const t = await req.text();
    return t ? JSON.parse(t) : {};
  } catch {
    return {};
  }
}
function isKnownReqError(e: any): boolean {
  return !!(e && typeof e === "object" && e.code && typeof e.code === "string");
}
export async function POST(req: Request) {
  try {
    const body = await safeJson(req);
    const pointId = String(body.pointId || "").trim();
    const action = String(body.action || "").toLowerCase().trim();
    const actor = String(body.actor || "anon").trim() || "anon";
    const note = String(body.note || "");
    if (!pointId) return NextResponse.json({ ok: false, error: "missing_pointId" }, { status: 400 });
    if (!action || !["confirm","support","replicar"].includes(action)) {
      return NextResponse.json({ ok: false, error: "bad_action" }, { status: 400 });
    }
    const pc: any = prisma as any;
    const keys = Object.keys(pc);
    const pointKey = pickDelegate(pc, ["ecoCriticalPoint", "ecoPoint", "ecoCriticalPointV2"])
      || (keys.find((k) => /point/i.test(k) && /eco/i.test(k)) || null);
    if (!pointKey) return NextResponse.json({ ok: false, error: "point_model_not_found" }, { status: 500 });
    const pointModel = findModelByDelegate(pointKey);
    if (!pointModel) return NextResponse.json({ ok: false, error: "dmmf_point_model_not_found", pointKey }, { status: 500 });
    const p = await pc[pointKey].findUnique({ where: { id: pointId } });
    if (!p) return NextResponse.json({ ok: false, error: "point_not_found" }, { status: 404 });
    const confirmKey = pickDelegate(pc, ["ecoCriticalPointConfirm", "ecoPointConfirm", "ecoCriticalConfirm"])
      || (keys.find((k) => /confirm/i.test(k) && /eco/i.test(k)) || null);
    const supportKey = pickDelegate(pc, ["ecoPointSupport", "ecoCriticalPointSupport"])
      || (keys.find((k) => /support/i.test(k) && /eco/i.test(k)) || null);
    const replicarKey = pickDelegate(pc, ["ecoPointReplicate", "ecoPointReplicar", "ecoCriticalPointReplicate"])
      || (keys.find((k) => (/replic/i.test(k) || /replicar/i.test(k)) && /eco/i.test(k)) || null);
    const ctx = { actor, note };
    let created = false;
    let targetKey: string | null = null;
    if (action === "confirm") targetKey = confirmKey;
    if (action === "support") targetKey = supportKey;
    if (action === "replicar") targetKey = replicarKey;
    if (targetKey) {
      const tm = findModelByDelegate(targetKey);
      if (tm) {
        const fk = findFkField(tm.name, pointModel.name) || "pointId";
        const base: AnyRec = {};
        if (hasField(tm.name, "id")) base.id = randId(action.slice(0, 1));
        base[fk] = pointId;
        if (hasField(tm.name, "actor")) base.actor = actor;
        if (hasField(tm.name, "note") && note) base.note = note;
        if (hasField(tm.name, "createdAt")) base.createdAt = new Date();
        if (hasField(tm.name, "updatedAt")) base.updatedAt = new Date();
        if (hasField(tm.name, "fingerprint")) base.fingerprint = "act-" + action + "-" + Date.now().toString(36) + "-" + Math.random().toString(36).slice(2, 8);
        const data = buildRequiredData(tm.name, base, ctx);
        try {
          await pc[targetKey].create({ data });
          created = true;
        } catch (e: any) {
          if (isKnownReqError(e) && e.code === "P2002") {
            created = false;
          } else {
            throw e;
          }
        }
      }
    }
    const counts: AnyRec = { confirm: 0, support: 0, replicar: 0 };
    if (confirmKey) {
      const cm = findModelByDelegate(confirmKey);
      const ck = cm ? (findFkField(cm.name, pointModel.name) || "pointId") : "pointId";
      try { counts.confirm = await pc[confirmKey].count({ where: { [ck]: pointId } }); } catch { void 0; }
    }
    if (supportKey) {
      const sm = findModelByDelegate(supportKey);
      const sk = sm ? (findFkField(sm.name, pointModel.name) || "pointId") : "pointId";
      try { counts.support = await pc[supportKey].count({ where: { [sk]: pointId } }); } catch { void 0; }
    }
    if (replicarKey) {
      const rm = findModelByDelegate(replicarKey);
      const rk = rm ? (findFkField(rm.name, pointModel.name) || "pointId") : "pointId";
      try { counts.replicar = await pc[replicarKey].count({ where: { [rk]: pointId } }); } catch { void 0; }
    }
    return NextResponse.json({
      ok: true,
      error: null,
      pointId,
      action,
      created,
      counts,
      models: { pointKey, confirmKey, supportKey, replicarKey },
    });
  } catch (e: any) {
    const msg = e && e.message ? String(e.message) : String(e);
    return NextResponse.json({ ok: false, error: "action_failed", message: msg }, { status: 500 });
  }
}
