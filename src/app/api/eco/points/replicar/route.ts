// AUTO-GENERATED by tools/eco-step-108-add-mural-actions-endpoints-v0_1.ps1
// ECO Mural action endpoint: 
import { NextResponse } from "next/server";
import { prisma } from "@/lib/prisma";
import { Prisma } from "@prisma/client";
export const runtime = "nodejs";
export const dynamic = "force-dynamic";

function toDelegate(name: string) {
  return name && name.length ? name.slice(0, 1).toLowerCase() + name.slice(1) : name;
}

function getDmmf(): any {
  return (Prisma as any).dmmf as any;
}

function getModels(): any[] {
  const d = getDmmf();
  return d && d.datamodel && Array.isArray(d.datamodel.models) ? d.datamodel.models : [];
}

function getEnums(): any[] {
  const d = getDmmf();
  return d && d.datamodel && Array.isArray(d.datamodel.enums) ? d.datamodel.enums : [];
}

function enumFirst(enumName: string): string | null {
  const e = getEnums().find((x: any) => x && x.name === enumName);
  const v = e && Array.isArray(e.values) && e.values.length ? e.values[0].name : null;
  return v || null;
}

function findModelByDelegate(delegateKey: string): any | null {
  return getModels().find((m: any) => m && toDelegate(m.name) === delegateKey) || null;
}

function findModelByName(modelName: string): any | null {
  return getModels().find((m: any) => m && m.name === modelName) || null;
}

function hasField(modelName: string, fieldName: string): boolean {
  const m = findModelByName(modelName);
  return !!(m && Array.isArray(m.fields) && m.fields.some((f: any) => f && f.name === fieldName));
}

function pickDelegate(pc: any, candidates: string[]): string | null {
  for (const c of candidates) {
    if (pc && pc[c]) return c;
  }
  return null;
}

function randId(prefix: string) {
  return prefix + "-" + Math.random().toString(36).slice(2, 8) + "-" + Date.now().toString(36);
}

function findPointFkField(modelName: string): string {
  const m = findModelByName(modelName);
  const fields = m && Array.isArray(m.fields) ? m.fields : [];
  // prefer scalar pointId
  const f1 = fields.find((f: any) => f && f.kind === "scalar" && /pointId/i.test(f.name));
  if (f1 && f1.name) return f1.name;
  // fallback: anything containing point and ending Id
  const f2 = fields.find((f: any) => f && f.kind === "scalar" && /point/i.test(f.name) && /Id$/i.test(f.name));
  if (f2 && f2.name) return f2.name;
  return "pointId";
}

function buildRequiredData(modelName: string, base: Record<string, any>, ctx: any): any {
  const m = findModelByName(modelName);
  const out: any = {};
  const now = new Date();
  const fields = m && Array.isArray(m.fields) ? m.fields : [];

  for (const f of fields) {
    if (!f) continue;
    if (f.isList) continue;
    if (f.kind !== "scalar" && f.kind !== "enum") continue;
    if (!f.isRequired) continue;
    if (f.hasDefaultValue) continue;
    if (base && base[f.name] !== undefined) continue;

    if (f.name === "id") { out[f.name] = randId("id"); continue; }
    if (f.name === "createdAt" || f.name === "updatedAt") { out[f.name] = now; continue; }
    if (f.name === "actor") { out[f.name] = ctx.actor; continue; }
    if (f.name === "fingerprint") { out[f.name] = ctx.fingerprint; continue; }

    if (f.kind === "enum") { out[f.name] = enumFirst(f.type) || ctx.enumFallback; continue; }
    if (f.type === "String") { out[f.name] = ctx.actor; continue; }
    if (f.type === "Int" || f.type === "Float") { out[f.name] = 0; continue; }
    if (f.type === "Boolean") { out[f.name] = false; continue; }
    if (f.type === "DateTime") { out[f.name] = now; continue; }

    out[f.name] = ctx.actor;
  }

  for (const k of Object.keys(base || {})) out[k] = (base as any)[k];

  // helpful optional fields
  if (hasField(modelName, "note") && out["note"] === undefined) out["note"] = ctx.note;

  return out;
}

function readCookie(req: Request, name: string): string | null {
  const h = req.headers.get("cookie") || "";
  const parts = h.split(/;\s*/);
  for (const p of parts) {
    const eq = p.indexOf("=");
    if (eq <= 0) continue;
    const k = p.slice(0, eq).trim();
    if (k !== name) continue;
    const v = p.slice(eq + 1);
    try { return decodeURIComponent(v); } catch { return v; }
  }
  return null;
}

function readActorFromReq(req: Request, body: any): string {
  const c1 = readCookie(req, "eco_actor");
  const c2 = readCookie(req, "nika_email");
  const h = req.headers.get("x-actor");
  const b = body && typeof body.actor === "string" ? body.actor : null;
  return (h && h.trim()) || (b && b.trim()) || (c1 && c1.trim()) || (c2 && c2.trim()) || "anon";
}

export async function POST(req: Request) {
  try {
    const body = await req.json().catch(() => ({} as any));
    const pointId = body && typeof body.pointId === "string" ? body.pointId : null;
    if (!pointId) return NextResponse.json({ ok: false, error: "missing_pointId" }, { status: 400 });

    const pc: any = prisma as any;
    const keys = Object.keys(pc);
    const actionKey = pickDelegate(pc, [
"ecoPointReplicate", "ecoPointReplicar", "ecoCriticalPointReplicate"
]) || (keys.find((k) => /replicar/i.test(k) && /eco/i.test(k)) || null);
    if (!actionKey) return NextResponse.json({ ok: false, error: "action_model_not_found" }, { status: 500 });

    const am = findModelByDelegate(actionKey);
    if (!am) return NextResponse.json({ ok: false, error: "dmmf_action_model_not_found", actionKey }, { status: 500 });

    const fk = findPointFkField(am.name);
    const actor = readActorFromReq(req, body);

    // "ensure" (1 por actor por ponto) quando o model tiver actor
    if (hasField(am.name, "actor")) {
      const where: any = {};
      where[fk] = pointId;
      where["actor"] = actor;
      const existing = await pc[actionKey].findFirst({ where }).catch(() => null);
      if (existing) {
        return NextResponse.json({ ok: true, error: null, created: false, already: true, pointId, actor, model: actionKey });
      }
    }

    const base: any = {};
    if (hasField(am.name, "id")) base.id = randId("r");
    base[fk] = pointId;
    if (hasField(am.name, "actor")) base.actor = actor;
    if (hasField(am.name, "fingerprint")) base.fingerprint = "fp-" + pointId + "-" + Date.now().toString(36);
    if (hasField(am.name, "createdAt")) base.createdAt = new Date();

    const ctx = { actor, note: "seed", fingerprint: "fp-" + pointId + "-" + Date.now().toString(36), enumFallback: "OPEN" };
    const data = buildRequiredData(am.name, base, ctx);
    await pc[actionKey].create({ data });

    return NextResponse.json({ ok: true, error: null, created: true, pointId, actor, model: actionKey });
  } catch (e: any) {
    const msg = e && e.message ? String(e.message) : String(e);
    return NextResponse.json({ ok: false, error: "action_failed", message: msg }, { status: 500 });
  }
}
