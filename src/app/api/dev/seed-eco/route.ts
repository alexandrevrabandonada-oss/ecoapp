// AUTO-GENERATED by tools/eco-step-106f2-fix-seed-eco-dmmf-required-v0_2.ps1
// Dev-only seed for ECO points/confirm/support/replicar â€” fills required scalar/enum fields via Prisma.dmmf safely.

import { NextResponse } from "next/server";
import { prisma } from "@/lib/prisma";
import { Prisma } from "@prisma/client";

export const runtime = "nodejs";
export const dynamic = "force-dynamic";

type AnyModel = { name: string; fields: any[] };

function lowerFirst(s: string) { return s ? s.slice(0,1).toLowerCase() + s.slice(1) : s; }

function getDmmf(): any {
  return (Prisma as any).dmmf as any;
}

function models(): AnyModel[] {
  const d = getDmmf();
  const ms = d?.datamodel?.models;
  return Array.isArray(ms) ? ms : [];
}

function enums(): any[] {
  const d = getDmmf();
  const es = d?.datamodel?.enums;
  return Array.isArray(es) ? es : [];
}

function enumVals(enumName: string): string[] {
  const e = enums().find((x: any) => x?.name === enumName);
  if (!e || !Array.isArray(e.values)) return [];
  return e.values.map((v: any) => (typeof v === "string" ? v : v?.name)).filter(Boolean);
}

function pickEnum(enumName: string, preferred?: string): string | null {
  const vs = enumVals(enumName);
  if (!vs.length) return null;
  if (preferred && vs.includes(preferred)) return preferred;
  return vs[0];
}

function findModelByName(name: string): AnyModel | null {
  return models().find((m) => m?.name === name) || null;
}

function findModelByRegex(re: RegExp): AnyModel | null {
  return models().find((m) => m?.name && re.test(m.name)) || null;
}

function hasField(modelName: string, fieldName: string): boolean {
  const m = findModelByName(modelName);
  const fs = m?.fields;
  return Array.isArray(fs) ? fs.some((f: any) => f?.name === fieldName) : false;
}

function findRelatedModel(nameRe: RegExp, pointModelName: string): AnyModel | null {
  return models().find((m) => {
    if (!m?.name || !nameRe.test(m.name)) return false;
    const fs = Array.isArray(m.fields) ? m.fields : [];
    return fs.some((f: any) => f?.kind === "object" && f?.type === pointModelName);
  }) || null;
}

function findFkField(modelName: string, targetModelName: string): string | null {
  const m = findModelByName(modelName);
  const fs = Array.isArray(m?.fields) ? m!.fields : [];
  // prefer relationFromFields on the object relation
  for (const f of fs) {
    if (f?.kind === "object" && f?.type === targetModelName) {
      const rff = (f as any).relationFromFields;
      if (Array.isArray(rff) && rff.length) return rff[0];
    }
  }
  // fallback: pointId-like scalar
  const scalar = fs.find((f: any) => (f?.kind === "scalar" || f?.kind === "enum") && /pointId/i.test(f.name));
  return scalar ? scalar.name : null;
}

function randId(prefix: string) {
  return prefix + "-" + Math.random().toString(36).slice(2, 8) + "-" + Date.now().toString(36);
}

function buildRequiredData(modelName: string, base: Record<string, any>, idx: number, ctx: any): any {
  const m = findModelByName(modelName);
  if (!m) throw new Error("dmmf_model_not_found:" + modelName);
  const out: any = {};
  const now = new Date();
  const fs = Array.isArray(m.fields) ? m.fields : [];

  for (const f of fs) {
    if (!f || f.isList) continue;
    if (f.kind !== "scalar" && f.kind !== "enum") continue;
    if (!f.isRequired) continue;
    if (f.hasDefaultValue) continue;
    if (base && base[f.name] !== undefined) continue;

    // common fields
    if (f.name === "id") { out[f.name] = randId(modelName.toLowerCase().slice(0,2)); continue; }
    if (f.name === "createdAt" || f.name === "updatedAt") { out[f.name] = now; continue; }
    if (f.name === "lat") { out[f.name] = ctx.latBase + idx * ctx.step; continue; }
    if (f.name === "lng") { out[f.name] = ctx.lngBase + idx * ctx.step; continue; }
    if (f.name === "actor") { out[f.name] = ctx.actor; continue; }
    if (f.name === "kind") {
      if (f.kind === "enum") { out[f.name] = pickEnum(f.type, ctx.kind) || ctx.kind; }
      else { out[f.name] = ctx.kind; }
      continue;
    }
    if (f.name === "status") {
      if (f.kind === "enum") { out[f.name] = pickEnum(f.type, ctx.status) || ctx.status; }
      else { out[f.name] = ctx.status; }
      continue;
    }
    if (f.name === "fingerprint") { out[f.name] = "seed-" + idx + "-" + Math.random().toString(36).slice(2); continue; }

    if (f.kind === "enum") { out[f.name] = pickEnum(f.type) || ctx.kind; continue; }

    // by scalar type
    if (f.type === "String") { out[f.name] = "seed"; continue; }
    if (f.type === "Int" || f.type === "Float") { out[f.name] = 0; continue; }
    if (f.type === "Boolean") { out[f.name] = false; continue; }
    if (f.type === "DateTime") { out[f.name] = now; continue; }

    out[f.name] = "seed";
  }

  // merge base last (base wins)
  for (const k of Object.keys(base || {})) out[k] = (base as any)[k];

  // helpful optional fields
  if (hasField(modelName, "note") && out.note === undefined) out.note = "seed";
  if (hasField(modelName, "photoUrl") && out.photoUrl === undefined) out.photoUrl = null;

  return out;
}

function pickDelegate(prismaAny: any, modelName: string): string | null {
  const key = lowerFirst(modelName);
  return prismaAny && prismaAny[key] ? key : null;
}

export async function GET(req: Request) {
  try {
    if (process.env.NODE_ENV !== "development") {
      return NextResponse.json({ ok: false, error: "forbidden" }, { status: 404 });
    }

    const d = getDmmf();
    if (!d?.datamodel?.models) {
      return NextResponse.json({ ok: false, error: "dmmf_unavailable" }, { status: 500 });
    }

    const url = new URL(req.url);
    const nRaw = Number(url.searchParams.get("n") || "3") || 3;
    const n = Math.max(1, Math.min(50, nRaw));
    const doConfirm = (url.searchParams.get("confirm") || "0") !== "0";
    const doSupport = (url.searchParams.get("support") || "0") !== "0";
    const doReplicar = (url.searchParams.get("replicar") || "0") !== "0";

    const prismaAny: any = prisma as any;

    // 1) point model
    const pointModel = findModelByName("EcoCriticalPoint") || findModelByRegex(/Eco.*Point/i);
    if (!pointModel) return NextResponse.json({ ok: false, error: "point_model_not_found" }, { status: 500 });
    const pointKey = pickDelegate(prismaAny, pointModel.name);
    if (!pointKey) return NextResponse.json({ ok: false, error: "point_delegate_not_found", model: pointModel.name }, { status: 500 });

    // 2) related models
    const confirmModel = findRelatedModel(/Confirm/i, pointModel.name);
    const supportModel = findRelatedModel(/Support/i, pointModel.name) || findRelatedModel(/Apoia/i, pointModel.name);
    const replicarModel = findRelatedModel(/Replic/i, pointModel.name) || findRelatedModel(/Replicar/i, pointModel.name);

    const confirmKey = confirmModel ? pickDelegate(prismaAny, confirmModel.name) : null;
    const supportKey = supportModel ? pickDelegate(prismaAny, supportModel.name) : null;
    const replicarKey = replicarModel ? pickDelegate(prismaAny, replicarModel.name) : null;

    const ctx = {
      actor: url.searchParams.get("actor") || "dev",
      kind: url.searchParams.get("kind") || "LIXO_ACUMULADO",
      status: url.searchParams.get("status") || "OPEN",
      latBase: Number(url.searchParams.get("lat") || "-22.5200"),
      lngBase: Number(url.searchParams.get("lng") || "-44.1040"),
      step: 0.001,
    };

    // ensure preferred enums exist
    // If kind/status are enum, pick a valid value when preferred is not present
    if (hasField(pointModel.name, "kind")) {
      const f = pointModel.fields.find((x: any) => x?.name === "kind");
      if (f?.kind === "enum") ctx.kind = pickEnum(f.type, ctx.kind) || (pickEnum(f.type) || ctx.kind);
    }
    if (hasField(pointModel.name, "status")) {
      const f = pointModel.fields.find((x: any) => x?.name === "status");
      if (f?.kind === "enum") ctx.status = pickEnum(f.type, ctx.status) || (pickEnum(f.type) || ctx.status);
    }

    const createdIds: string[] = [];
    for (let i = 0; i < n; i++) {
      const id = randId("p");
      const base: any = { id };
      if (hasField(pointModel.name, "lat")) base.lat = ctx.latBase + i * ctx.step;
      if (hasField(pointModel.name, "lng")) base.lng = ctx.lngBase + i * ctx.step;
      if (hasField(pointModel.name, "kind")) base.kind = ctx.kind;
      if (hasField(pointModel.name, "status")) base.status = ctx.status;
      if (hasField(pointModel.name, "createdAt")) base.createdAt = new Date();
      if (hasField(pointModel.name, "updatedAt")) base.updatedAt = new Date();

      const data = buildRequiredData(pointModel.name, base, i, ctx);
      await prismaAny[pointKey].create({ data });
      createdIds.push(id);
    }

    let createdConfirm = 0, createdSupport = 0, createdReplicar = 0;

    if (doConfirm && confirmModel && confirmKey) {
      const fk = findFkField(confirmModel.name, pointModel.name);
      if (fk) {
        for (let i = 0; i < createdIds.length; i++) {
          const base: any = { id: randId("c") };
          base[fk] = createdIds[i];
          if (hasField(confirmModel.name, "actor")) base.actor = ctx.actor;
          if (hasField(confirmModel.name, "createdAt")) base.createdAt = new Date();
          const data = buildRequiredData(confirmModel.name, base, i, ctx);
          await prismaAny[confirmKey].create({ data });
          createdConfirm++;
        }
      }
    }

    if (doSupport && supportModel && supportKey) {
      const fk = findFkField(supportModel.name, pointModel.name);
      if (fk) {
        for (let i = 0; i < createdIds.length; i++) {
          const base: any = {};
          if (hasField(supportModel.name, "id")) base.id = randId("s");
          base[fk] = createdIds[i];
          if (hasField(supportModel.name, "note")) base.note = "seed";
          if (hasField(supportModel.name, "createdAt")) base.createdAt = new Date();
          const data = buildRequiredData(supportModel.name, base, i, ctx);
          await prismaAny[supportKey].create({ data });
          createdSupport++;
        }
      }
    }

    if (doReplicar && replicarModel && replicarKey) {
      const fk = findFkField(replicarModel.name, pointModel.name);
      if (fk) {
        for (let i = 0; i < createdIds.length; i++) {
          const base: any = {};
          if (hasField(replicarModel.name, "id")) base.id = randId("r");
          base[fk] = createdIds[i];
          if (hasField(replicarModel.name, "fingerprint")) base.fingerprint = "seed-" + i + "-" + Math.random().toString(36).slice(2);
          if (hasField(replicarModel.name, "createdAt")) base.createdAt = new Date();
          const data = buildRequiredData(replicarModel.name, base, i, ctx);
          await prismaAny[replicarKey].create({ data });
          createdReplicar++;
        }
      }
    }

    return NextResponse.json({
      ok: true,
      error: null,
      created: { points: createdIds.length, confirm: createdConfirm, support: createdSupport, replicar: createdReplicar },
      ids: createdIds,
      models: { point: { name: pointModel.name, key: pointKey }, confirm: confirmKey, support: supportKey, replicar: replicarKey },
      ctx,
    });
  } catch (e: any) {
    const msg = e?.message ? String(e.message) : String(e);
    return NextResponse.json({ ok: false, error: "seed_failed", message: msg }, { status: 500 });
  }
}
